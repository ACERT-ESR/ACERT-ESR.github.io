===========
Coding
===========

Design
--------

The central object of this code is the class
:class:`Spectrometer.Spectrometer` which is responsible
for aggregating cards in the machine for experiments.
Predefined experiments are all in :mod:`Experiments`.

.. note::

    Previously, these used definitions in :mod:`DQC`, :mod:`DQCPhaseCycling`, and :mod:`PhaseCycling` to define some of the experiments,
    but this older formatting should now be obsolete.

Data analysis uses :mod:`plot` and :mod:`util`. The utilities
also describe how to read configuration files and configure logging
facilities for debugging.

Most of the acqisition cards
are defined in :mod:`Devices`, but two signal generators are not.

SpinCore PulseBlaster
    This signal generator uses the modules :mod:`PBTiming` for most of its
    work, but the modules :mod:`PulseBlaster` helps to hook the older
    :mod:`PBTiming` code into the Spectrometer.

Chase DWG11000
    This signal generator's main class is :class:`ChaseGenerator.ChaseCard`.
    :mod:`ChasePulseProgram` is responsible for turning pulses into
    a signal you can start and stop. It uses the :mod:`PulseFrame`
    module to turn pulses into a pulse frame. `PulseFrame`, in turn,
    uses the :mod:`Timing` module to turn constraints into a schedule
    of signals to send.

There are several *mock* classes. These are used for testing the code
on machines where some, or all, of the devices are not available.

The file `Version.py` is written automatically during installation.
It enables the function `acert.hfesr.version()` which retrieves
the Subversion URL and version number.

Logging and Printing
----------------------

There are two ways to print messages. util.msg() sends messages
that will always to go the user. This is prefered to the print
statement because it can be redirected for batch operations
or execution under a GUI.

In addition, each module has a logger from the standard Python
logging facility. For instance, the Timing module defines::
  
    import logging
    logger = logging.getLogger('acert.hfesr.Timing')
    logger.debug("A message from the Timing module")

Each module has its own logger, but the logging facility treats
them hierarchically. If code adds a handler to the
``acert.hfesr`` logger, then that handler will listen to all events
under acert.hfesr. The logging facility provides handlers
to print to the screen or save to files.

The acert.hfesr.util.setup_logging function lets you choose
what level of logging you want to see. logging.INFO is the standard
setting, and logging.DEBUG will show lots of messages.

The acert.hfesr.util.trace_module function lets you choose to
trace a specific module. It saves those traces to hfesrtrace.txt
in the working directory.

If you are working interactively at the command line
and want to turn on logging, try::

  >>> import logging
  >>> logging.basicConfig(level=logging.DEBUG)
  
to turn on logging to the terminal for all messages.


Documentation
-----------------------------

The code is documented with Python's :mod:`sphinx` module.
Sphinx is configured to use the autodoc extension, which can
pull comments from the code. This feature is used in the 
documentation where it does not conflict with the flow of 
the documentation.

Sphinx is also configured to use a math extension so that
it can include math in its output::

    The length of the phase cycle is :math:`m^n`.

There are several possible
math modules for sphinx, but the math language is latex,
so it does not matter which extension you pick if you are
building latex documentation.

When embedding math documentation in code, be sure to escape
backslashes, so::

    def myfunction(arg):
        '''
        This function looks at :math:`+1\\rightarrow 0\\rightarrow -1`.
        '''

If you neglect to escape the backslash, you will get errors from
Sphinx that the block is indented improperly because ``\r`` is
a carriage return.

To build the documentation

#. cd docs
#. make latex
#. (cd _build/latex && make all-pdf)


Versioning
-------------------------

It might help to record the version of the code when you record data.
There is a function in the acert.hfesr module to tell you what
version of the code you are using.

.. function:: acert.hfesr.version()

    :return: (SVN directory of hfesr code, version number as a string)

This function depends on Subversion properties set on the __init__.py
file in the root hfesr directory and on the setup.py script creating
a module called hfesr/Version.py.
