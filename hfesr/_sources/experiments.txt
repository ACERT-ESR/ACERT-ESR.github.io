===========
Experiments
===========

-------------------
Running Experiments
-------------------

Most of the Python code to run this experiment is stored as a library.
You run the code by running a script called hfesr.
It initializes
the cards in the computer, requests the username and magnet current,
and defines several experiments that can be run. A sample
session is::

  $ hfesr
  95 GHz Spectrometer Interface (C) 2003, 2004, 2005 Wulf Hofbauer
  Searching for Acqiris digitizers ...
  1 Acqiris card(s) found
  PCI::INSTR0 (Serial #16900, PCI address 0.13) model 'AP240'
  Initializing AP240 digitizer #16900 at PCI 0.13 ...
  Using AP240, serial number #16900, for quadrature signal.
  Initializing Timing module ...
  Initializing EIP535 frequency counter at /dev/gpib0/dev3 ...
  Initializing Stanford SR510 lock-in amplifier at /dev/ttyS0 ...
  Initializing Stanford SR510 lock-in amplifier at /dev/ttyS1 ...
  Initializing Lakeshore 331S temperature controller at /dev/gpib0/dev12 ...

  >>> You are running as user 'acert'. <<<

  Please enter the persistent magnet current [A]: 29.2
  Thank you. A main coil current of 29.2 A will be assumed from now on.
  This corresponds to a main field of 3.40005 T.
  Spectrometer is s. Experiments are dqc128, deer4, and fid.
  Print s or any experiment to see its variables.
  help(s) or help(experiment) gives more information.
  Run an experiment, such as FID, with fid.run().
  95 GHz: print deer4
  95 GHz: deer4.averages=1000
  95 GHz: deer4.run()


Each experiment has the methods to show its settings, get help, run, plot,
and print. If you start with an instance of the FID class, stored in the
fid variable, you can find the parameters in that class with the print
function. To see all documentation on FID, use help(fid).

::

  95 GHz: print fid
  FID
    averages=32
    plots=None
    pulse_length=8e-09
    rep_rate=5000
    spectrometer=None
  95 GHz: help(fid)
     ...all of its documentation is printed here...

All experiments can be run by calling `run()`. The `plot()` function
calls the default plotting routine. There may be other routines,
as in ELDOR, which has another routine to do a contour plot.

::

  95 GHz: fid.run()
  95 GHz: fid.plot()
  95 GHz: fid.print_plot()

The last call prints the last set of plots you made. You have to make 
a plot before it can print one.


------
Tuning
------

Tuning is an experiment like any other, so it has run and print methods.
As part of the Predefined Experiments (next), there are various tuning methods for different situations.

----------------------
Predefined Experiments
----------------------

The predefined Fourier Transform ESR experiments are implemented using
a shared, generic acquisition routine that implements preflight
checking before the actual data acquisition is started. Beginning
and end of major steps in the process are indicated by messages
to the logging facility. In the case of lengthy preflights
or acquisitions, additiona messages are generated indicating progress.

Following are examples of pulse sequences for various Fourier
Transform ESR experiments. Top to bottom: free induction decay (FID),
spin echo correlation spectroscopy (SECSY), correlation spectroscopy
(COSY), and exchange correlation spectroscopy / 2D electron-electron
double resonance (2D-ELDOR/EXCSY).

.. image:: manual/pics/FTESRexperiments.png


.. {{{ the following was generated by first including experiment_autosum.rst, with the following content:
    .. autosummary:: 
        :toctree: generated
        [newline]
        Experiments
    (needed to comment out Gnuplot in plot.py to get this to work)
    then setting autosummary_generate = True in conf.py
    then copying and pasting the result here

.. currentmodule:: Experiments

.. rubric:: Functions

.. autosummary::
  :toctree: generated

  OnePulsedAcquisition
  PulsedAcquisition
  clearkey
  handle_break
  keypress
  plot_data
  test_experiments
  test_experiments_pulseblaster
  test_experiments_tune
  test_set_base

.. rubric:: Classes

.. autosummary::
  :toctree: generated

  B1_FID
  B1_echo
  B1_se
  COSY
  COSYAverages
  CW
  Constants
  DEER3
  DEER4
  DQC
  DQC128
  DQC256
  DQC64
  DQCBase
  ELDOR
  ELDOR_3D
  Echo
  Experiment
  FID
  FIDAverages
  Loopback
  PulseExperimentBase
  PulseTune
  SECSY
  T1_inv
  Tune
  Tune2
  Tune3
  TuneCWConstant
  TuneCWCycled
  TuneCycled
  TuneEcho
  TuneEchoCycled
  echo_T2
  split_inv_rec
   
.. }}} end autogenerated portion

Binned and Field-Stepped Experiments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As of 2015, binned and Field-Stepped Experiments are available.
A field-stepped version of every experiment (*e.g.* `ELDOR_fs` is a field-swept version of `ELDOR`) is now available from the command-line.

.. rubric:: Technical Details

The `ELDOR_fs` class instances are generated by setting ``field_sweep=True`` in the initialization routine of the experiment class (this assumes that `__init__` is inherited from the :class:`PulseExperimentBase`.
See the features of the :class:`PulseExperimentBase`, next.


Features Common to all Pulse Experiments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

All pulse experiment classes (which should inherit from `PulseExperimentBase`) have the following attributes and methods:

.. currentmodule:: Experiments

.. autosummary:: PulseExperimentBase

.. autoclass:: PulseExperimentBase
    :members:

DQC Phase Cycling
^^^^^^^^^^^^^^^^^

A whole module was developed for DQC phase cycling.  However, JMF recommends
staying away from this, since it introduces unnecessary complexity, so it was
removed from the manual.

---------------------------------
Designing New Experiments
---------------------------------

New experiments can be designed by writing Python code, algorithmically
describing the various steps needed to perform the experiment using the
functionality provided by the :mod:`Spectrometer` and supporting modules.

For consistency, it is recommended to follow the general outline of the
predefined experiments, which are defined as classes.

The right way: Use Classes
^^^^^^^^^^^^^^^^^^^^^^

Note also that these experiments attempt to gather and
preserve a lot of acquisition parameters, easing bookkeeping tasks. In many
cases, these bookkeeping tasks and error checking constitute the main part of
the code.
The code is set up to use object-oriented programming, which allows us to avoid duplicating this work.

For example, a default behavior for pulsed experiments is defined by the :class:`PulseExperimentBase` class
(which in turn inherits a default behavior that is useful to both cw and pulse experiments from the :class:`Experiments` class).
By making a new class that inherits from :class:`PulseExperimentBase`
(*i.e.*, defined as ``class NewExperimentName (PulseExperimentBase):``), you copy that default behavior.
You can then over-ride only the attributes or methods that you want to change.

A good way to proceed is as follows:

#. Copy the code for an experiment that is similar to the one you
   want, and search and replace (inside the copied code) the name
   of the old class with the name you have chosen for your new class. 

   - In many cases, the code could be further compacted by writing a new class from scratch that inherits from the existing experiment.  This requires a bit more experience to get the desired result, however.

#. Modify the `build_sequence` method to change the pulse sequence.

   - It is **strongly recommended** that you utilize the :func:`simple_sequence <Experiments.Experiment.simple_sequence>` routine documented below to generate a properly phase-cycled experiment.

#. In rare cases, modify the other routines in order to alter any on-the-fly plotting or saving routines.  For example, all of the `Tune`... classes have very specific `run` methods that control the real-time plot.

.. currentmodule:: Experiments

.. autofunction:: Experiments.simple_sequence

One-off experiments designed as functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For one-off experiments, however, it is perfectly possible to define a
simple Python function, hard-coding experimental parameters, etc. To illustrate
this, here is a minimalist (but fully phase-cycled) field-swept echo
experiment, spelled out step by step::

   def fse(s):
        import Numeric;         # for handling arrays
        import PhaseCycling;    # for creating phasecycles
        import time;            # for time delays

        rep_rate=5000;
        averages=128;

        # timing in nanoseconds
        pulse_length=8;
        pulse_separation=200;

        # define the sweep range
        B_min=3.39;
        B_max=3.4;
        B_steps=512;

        # calculate individual magnetic fields and
        # required sweep coil currents
        fields=Numeric.arange(B_min, B_max, (B_max-B_min)/B_steps);
        sweep_currents=(fields-s.get_main_field())/s.sweep_tesla_per_ampere;

        # use a full CYCLOPS phase cycle
        phasecycle=PhaseCycling.FullPhaseCycle(2);

        # create an empty array to hold the data
        data=Numeric.zeros((len(phasecycle), len(fields),
	        s.get_record_length()), Numeric.Complex);

        # loop over all desired fields
        for i in range(len(sweep_currents)):

                # set the sweep coil current
                s.set_sweep_current(sweep_currents[i]);

                # let the field settle for a bit
                time.sleep(0.2);

                # loop over all phase combinations
                for j in range(len(phasecycle)):
                        phases=phasecycle[j];

                        # define pulse sequence
                        ps=[(-pulse_separation-pulse_length/2,
                                pulse_length, phases[0]),
                                (-pulse_length/2, pulse_length,
                                phases[1])];

                        # compile sequence to a program
                        pp=s.compile_pulse_program(ps, averages,
                                rep_rate);

                        # start averager and run the pulse program
                        s.start_averager(averages);
                        s.run_pulse_program(pp);

                        # wait until the averager is done
                        while s.averager_busy(): time.sleep(0.01);

                        # read out averager
                        data[j,i]=s.read_averager();

        return data;

To run the experiment, the function would be called with the
:mod:`Spectrometer` module as its argument. On completion, the function
returns a 3D data array, where the first index represents the step in the
phasecycle, the second the magnetic field, and the third the time axis.

Such code might be written on the fly using a text editor, and the function
declaration loaded using the Python ``execfile`` function.

A simple, non-phasecycled FID experiment might even be conducted completely
from the command line::

   95 GHz: s=Spectrometer
   95 GHz: ps=[(-4, 8, 0)]         # a single pulse
   95 GHz: pp=s.compile_pulse_program(ps, 4096, 5000)
   95 GHz: s.start_averager(4096)
   95 GHz: pp.run()
   95 GHz: s.averager_busy()       # check if acquisition done
   1
   95 GHz: s.averager_busy()
   0
   95 GHz: data=s.read_averager()

